\documentclass{probook}

\usepackage{multicol}

\geometry{
  paperwidth=290mm,
  paperheight=210mm,
  margin=20mm,
  left=15mm,
  right=15mm,
}

\title{ACM 模板}
\author{\href{https://github.com/rogeryoungh}{rogeryoungh}}

\begin{document}
\newcommand\mfrac[2]{\dfrac{#1\smash[b]{\strut}}{#2\smash[t]{\strut}}}
\newcommand\ee{\mathrm{e}}
\newcommand\dd{\mathrm{d}}
\newcommand\uppi{\mathrm{\pi}}

\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\DFT}{\operatorname{DFT}_{\omega_n}}
\newcommand{\Id}{\operatorname{Id}}

\maketitle

\frontmatter

\columnseprule=2pt
\setlength{\columnsep}{30pt}
\begin{multicols}{2}

\tableofcontents

\mainmatter






\chapter{上号}

\section{头文件}

\lstinputlisting[style=cpp,caption=/上号/头文件.hpp]{上号/头文件.hpp}

\section{预编译}

头文件引入方式改为如下，可以把头文件放入 \lstinline[style=cpp]{lab.hpp} ，然后使用 \lstinline[language=bash]{clang++ lab.hpp} 预编译。实际编译使用 \lstinline[language=bash]{clang++ lab.cpp -DRYLOCAL} 添加条件编译参数。

\begin{lstlisting}[style=cpp]
#ifdef RYLOCAL
#include "lab.hpp"
#else  //#include <bits/stdc++.h>
#include <cstdio> #include <iostream> #include <functional>
#include <cmath>  #include <cstring>  #include <algorithm>
#endif
\end{lstlisting}

\section{进制转换}

\lstinputlisting[style=cpp,caption=/上号/进制转换.cpp]{上号/进制转换.cpp}

\section{常见技巧}

向上取整 $p/q$ 为 \lstinline[style=cpp]{(p-1)/q+1} 。

预计算 $\log_n$，只需 \lstinline[style=cpp]{_fora(i, n, MN) logn[i] = logn[i/n] + 1;}。

字典序 \lstinline[style=cpp]{strcmp(x,y) < 0}。

\section{二分查找}

\paragraph*{STL 二分}

在 $[l,r)$ 查找 $\geqslant v$ 中最前的一个，找不到则返回 $r$ 。支持 cmp 函数。

\begin{lstlisting}[style=cpp]
T* lower_bound(T* l, T* r, const T& v);
\end{lstlisting}

在 $[l,r)$ 查找 $> value$ 中最前的一个，找不到则返回 $r$ 。支持 cmp 函数。

\begin{lstlisting}[style=cpp]
T* upper_bound(T* l, T* r, const T& v);
\end{lstlisting}

手写二分，在单增（单减）数组中查找 $\geqslant x(\leqslant x)$ 的数中最前的一个。

\lstinputlisting[style=cpp,caption=/上号/二分/01.cpp]{上号/二分/01.cpp}

在单增（单减）数组中查找 $\leqslant x(\geqslant x)$ 的数中最后的一个。

\lstinputlisting[style=cpp,caption=/上号/二分/02.cpp]{上号/二分/02.cpp}

对于上凸（$\wedge$ 形）函数，可以使用三分法来查找最大值。对于下凸（$\vee$ 形）变号即可

\lstinputlisting[style=cpp,caption=/上号/三分法.cpp]{上号/三分法.cpp}

\section{矩阵乘法}

构建一个 $p$ 行 $q$ 列的矩阵。

\lstinputlisting[style=cpp,caption=/上号/矩阵乘法.cpp]{上号/矩阵乘法.cpp}

矩阵的输入、输出。

\begin{lstlisting}[style=cpp]
void read(Mtx& mtx) {
    _fora(i, 1, mtx.p) _fora(j, 1, mtx.q)
        mtx.m[i][j] = (MOD + rr()) % MOD;
}
void pr(Mtx mtx) {
    _fora(i, 1, mtx.p) {
        printf("%lld",mtx.m[i][1]);
        _fora(j, 2, mtx.q)
            printf(" %lld",mtx.m[i][j]);
        putchar('\n');
    }
}
\end{lstlisting}

\section{快速幂}

\lstinputlisting[style=cpp,caption=/上号/快速幂.cpp]{上号/快速幂.cpp}

\lstinputlisting[style=cpp,caption=/上号/矩阵快速幂.cpp]{上号/矩阵快速幂.cpp}

\section{快速排序}

\lstinputlisting[style=cpp,caption=/上号/快速排序.cpp]{上号/快速排序.cpp}

\section{\texorpdfstring{第 $k$ 大数}{第 k 大数}}

\lstinputlisting[style=cpp,caption=/上号/第 k 大数.cpp]{上号/第k大数.cpp}

\section{归并排序求逆序对}

\lstinputlisting[style=cpp,caption=/上号/逆序对.cpp]{上号/逆序对.cpp}







\chapter{数学}

\section{GCD 和 LCM}

\lstinputlisting[style=cpp,caption=/数学/gcdlcm.cpp]{数学/gcdlcm.cpp}

\section{EXGCD}

对于方程 
\[ax+by=\gcd(a,b)\]
可通过 $\rm exgcd$ 求出一个整数解。

\lstinputlisting[style=cpp,caption=/数学/exgcd.cpp]{数学/exgcd.cpp}

方程 $ax+by=c$ 有解的充要条件是 $\gcd(a,b) \mid c$。

\lstinputlisting[style=cpp,caption=/数学/liEu.cpp]{数学/liEu.cpp}

\section{数论函数}

数论函数是 $\mathbb{N}^+ \to \mathbb{C}$ 的函数。

\paragraph{定义}
常见函数 $\varepsilon(n) \coloneqq [n=1]$，$1(n) \coloneqq 1$，$\Id_k(n) \coloneqq n^k$，$\sigma_k(n) = \sum\limits_{d \mid n} d^k$。

设 $n > 1$ 的唯一分解式是
\[ n = p_1^{k_1}p_2^{k_2}\cdots p_s^{k_s} \]
则 $\omega(n) = s$，$\Omega(n) = \sum k_i$。$\nu(n) = (-1)^{\omega(n)}$，$\lambda(n) = (-1)^{\Omega(n)}$。

Euler $\varphi$ 函数：
\[ \varphi(m) \coloneqq \sum_{i=1}^m [\gcd(i,m) = 1] = m \prod_{p \mid n}\left( 1-\frac{1}{p} \right) \]

Mobius $\mu$ 函数：
\[ \mu(n) = \begin{cases}
    1, &n=1\\
    0, &\exists d > 1, d^2 \mid n\\
    (-1)^{\omega(n)}, &\text{otherwise}
\end{cases} \]

若数论函数 $f$ 满足对 $\gcd(a,b)$ 有 $f(ab) = f(a)f(b)$，则称为积性函数；若有 $f(ab) = f(a) + f(b)$ 则称为加性函数。若 $f,g$ 为积性函数，则 $f(x^p),f^p(x),fg(x),f \ast g$ 都是积性函数。

积性函数有 $\varphi,\varepsilon,1,\Id_k,\sigma_k,\nu,\lambda$，加性函数有 $\omega,\Omega$。

\paragraph{性质}
$\varphi(m)$ 的性质：$\varphi(p^k) = (p-1)p^{k-1}$。

\[ \varphi(m) = m \prod_{p \mid n}\left( 1-\frac{1}{p} \right), \sum_{d \mid m} \varphi(d) = m \]

$\mu(m)$ 的性质：$\sum\limits_{d \mid n} \mu(d) = [n=1] = \varepsilon$。

Femmat - Euler 定理：当 $\gcd(a,m) = 1$ 时，有
\[ a^{\varphi(m)} \equiv 1 \pmod m \]
推广，不要求互质，当 $b \geqslant \varphi(m)$ 时有
\[ a^b \equiv a^{b \bmod \varphi(m) + \varphi(m) } \]

\section{乘法逆元}

方程 $ax \equiv 1 \pmod p$ 有解的充要条件是 $\gcd(a,p) = 1$。

容易想到它与方程 $ax + py = c$ 等价，于是可以利用 $\rm exgcd$ 求最小正解。

\lstinputlisting[style=cpp,caption=/数学/逆元/exgcd法.cpp]{数学/逆元/exgcd法.cpp}

仅当 $p$ 为质数时，由 Fermat 小定理知 $x \equiv a^{p-2} \pmod p$。

\lstinputlisting[style=cpp,caption=/数学/逆元/快速幂法.cpp]{数学/逆元/快速幂法.cpp}

\section{筛法}

\paragraph{Eratosthenes 筛}

复杂度 $O(n\log \log n)$。

\lstinputlisting[style=cpp,caption=/数学/筛法/Eratosthenes.cpp]{数学/筛法/Eratosthenes.cpp}

\paragraph{Euler 筛}

复杂度 $O(n)$，每个合数只会被筛一次。

\lstinputlisting[style=cpp,caption=/数学/筛法/Euler.cpp]{数学/筛法/Euler.cpp}

\paragraph{Euler 筛 + MobiusMu + EulerPhi}

由于 Euler 筛过程中会把每一个数拆分成两个互质的因数，因此可以用来预处理积性函数和加性函数。如 Euler 筛 + $\mu(m)$ + $\phi(m)$，复杂度 $O(n)$。

\lstinputlisting[style=cpp,caption=/数学/筛法/Sieve.cpp]{数学/筛法/Sieve.cpp}

\section{素性测试}

\subsection{试除法}

\lstinputlisting[style=cpp,caption=/数学/试除法.cpp]{数学/试除法.cpp}

\subsection{Miller Rabbin}

如果 $n\leqslant 2^{32}$，那么 $ppp$ 取 $2,7,61$；如果 $ppp$ 选择 $2,3,7,61,24251$，那么 $10^{16}$ 内只有唯一的例外。如果莫名 WA 了，就多取点素数吧。

\lstinputlisting[style=cpp,caption=/数学/Miller\_Rabbin.cpp]{数学/Miller_Rabbin.cpp}

\subsection{排列组合}

\subsection{Lucas 定理}

当 $n,m$ 很大而 $p$ 较小的时候，有
\[  
\binom{n}{m}\bmod p = \binom{\left\lfloor n/p \right\rfloor}{\left\lfloor m/p\right\rfloor}\cdot\binom{n\bmod p}{m\bmod p}\bmod p 
\]

\lstinputlisting[style=cpp,caption=/数学/Lucas.cpp]{数学/Lucas.cpp}

\section{约瑟夫 Josephus 问题}

对 $n$ 个人进行标号 $0,\cdots,n-1$，顺时针站一圈。从 $0$ 号开始，每一次从当前的人继续顺时针数 $k$ 个，然后让这个人出局，如此反复。

设最后剩下的人的编号为 $J(n,k)$，有递推式
\[J(n+1,k) = (J(n,k)+k) \bmod (n+1)\]
踢出第一个人 $k$ 后，剩下就转化为 $J(n,k)$ 的情景，还原编号只需增加相对位移 $k$。

\lstinputlisting[style=cpp,caption=/数学/Josephus.cpp]{数学/Josephus.cpp}

\section{中国剩余定理}

若 $n_i$ 中任意两个互质，求方程组的解
\[ x \equiv a_i \pmod {n_i} , \quad i \in \{ 1,2,\cdots,k \} \]

\lstinputlisting[style=cpp,caption=/数学/China.cpp]{数学/China.cpp}

\section{Mobius 反演}

对于数论函数 $f(x)$ 和 $g(x)$，定义 $h(x)$ 为
\[ h(x) = \sum_{d \mid x} f(d) g\left(\frac{x}{d}\right) = \sum_{ab = x} f(a)g(b) \]
为其 Dirichlet 卷积，简记为 $h = f \ast g$。

Dirichlet 卷积满足交换律、结合律、分配律等，其上有单位元 $\varepsilon$ 和逆元，换言之其与数论函数构成了一个整环。

对于数论函数 $f(n)$，有 $F = f \ast 1 \Rightarrow f = F \ast \mu$。

即对于数论函数 $f(n)$，有
\[ F(n) = \sum_{d \mid n} f(d) \Rightarrow f(n) = \sum_{d \mid n} \mu(d)f\left(\frac{n}{d}\right) \]
以及
\[ F(n) = \sum_{n \mid d} f(d) \Rightarrow f(n) = \sum_{n \mid d} \mu\left(\frac{d}{n}\right)F(d) \]
常见的有
\[ \begin{matrix}
    1 = \varepsilon \ast 1, & \sigma_k = \Id_k \ast 1,& d = 1 \ast 1 \\
    \Id = \varphi \ast 1, & 1_{\operatorname{Sq}} = \lambda \ast 1, &(d \ast 1)^2 = d^3 \ast 1
\end{matrix} \]

\paragraph{整除分块}
令 $A = \{ \lfloor n/d \rfloor \mid 1 \leqslant d \leqslant n \}$，则 $|A| \leqslant 2\sqrt{n}$，即整除求和时可以做到 $\sqrt{n}$ 的速度。

\lstinputlisting[style=cpp,caption=/数学/整除分块/01.cpp]{数学/整除分块/01.cpp}

假如求和的是 $\sum\limits_{i=1}^{\min(n,m)} \left\lfloor \frac{n}{i} \right\rfloor\left\lfloor \frac{m}{i} \right\rfloor$，则可以用二维分块的技巧


\lstinputlisting[style=cpp,caption=/数学/整除分块/02.cpp]{数学/整除分块/02.cpp}

\section{博弈}

下面都是石子游戏，轮流取走物品。方便起见，称场上 $n$ 堆石子 $a_1,\cdots,a_n$ 为局势。先手必输的局势称为奇异局势

\subsection{Nim 博弈}

有 $n$ 堆分别有 $a_i$ 个物品，两人轮流取走任意一堆的任意个物品，不能不取，最后取光者获胜。奇异局势判定
\[a_1 \oplus \cdots \oplus a_n =0\]

\subsection{Wythoff 博奕}

两堆分别有 $a,b$ 各物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，不可不取，最后取光者获胜。

\lstinputlisting[style=cpp,caption=/数学/博弈/Wythoff.cpp]{数学/博弈/Wythoff.cpp}

特点：所有自然数都出现在奇异局势中，不重不漏。

\section{生成函数}

\paragraph{普通生成函数}
可以把序列 $\{a_n\}$ 映射到形式幂级数
\[ a(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_nx^n + \cdots \]
这样就可以通过对级数的研究得到序列的性质。记作 $f_n = [x^n]F(x)$。

生成函数的四则运算是显然的。其中 $F(x)G(x) = \{\sum\limits_{i=0}^n f_ig_{n-i}\}$ 为序列 $\{f_n\}$ 与 $\{g_n\}$ 的卷积。

对生成函数移位可以乘除 $x^m$，也可以对生成函数逐项求导、逐项积分。求生成函数的部分和，即是 $(1-x)^{-1}F(x)$。

基础函数：
\begin{equation*}
    \begin{aligned}
        \frac{1}{1-cx} &= \sum_{k=0}^\infty c^nx^n\\
        \frac{x}{1-x-x^2} &= \sum_{k=0}^\infty F_nx^n \\
        \ee^{cx} &= \sum_{k=0}^\infty \frac{c^nx^n}{n!} \\
        \ln(1+x) &= \sum_{k=1}^\infty \frac{(-1)^{n-1}}{n} x^n\\
        -\ln(1-x) &= \sum_{k=1}^\infty \frac{1}{n} x^n
    \end{aligned}
\end{equation*}

五边形数定理：
\[ \prod_{i=1}^\infty (1-x^i) = \sum_{k=0}^{\infty} (-1)^k x^{k(3k \pm 1) /2} \]



\section{容斥原理}

对于有限集 $S$，它的子集 $A,B,C$ 有
\[ |A \cup B \cup C| = |A| + |B| + |C| - |A\cap B| - |B \cap C| - |C \cap A| + |A \cap B \cap C| \]
对于 $n$ 个集合的情况，

容斥原理：设有限集 $S$ 的 $n$ 个子集 $A_i$，则有
\[ \left|\bigcup _{i=1}^{n}A_{i}\right|=\sum _{\varnothing \neq J\subseteq \{1,2,\ldots ,n\}}(-1)^{|J|-1}\left| \bigcap _{j\in J}A_{j} \right| \]

\paragraph{Burnside 引理}
设 $A$ 和 $B$ 为有限集合，$X=B^A$ 表示所有从 $A \to B$ 的映射。$G$ 是 $A$ 上的置换群，$X/G$ 表示 $G$ 作用在 $X$ 上产生的所有等价类的集合（若 $X$ 中的两个映射经过 $G$ 中的置换作用后相等，则它们在同一等价类中），则
\[ |X/G|=\frac{1}{|G|}\sum_{g\in G}|X^g| \]
其中 $|S|$ 表示集合 $S$ 中元素的个数，且
\[ X^g = \{ x \mid x \in X,g(x) = x \} \]

\paragraph{Polya 定理}
前置条件与 Burnside 引理相同
\[ |X/G|=\frac{1}{|G|}\sum_{g\in G}|B|^{c(g)} \]
其中 $c(g)$ 表示置换 $g$ 能拆分成不相交的循环置换的数量。

\section{组和排列}

\subsection{数学常数}

\paragraph{排列数}
从 $n$ 个不同元素中取 $m$ 个不同元素按顺序排成的一列称作一个排列，则排列种数为 
\[ A_n^m = n(n-1)\cdots (n-m+1) = \frac{n!}{(n-m)!} \]
若元素可重复取出，则为 $n^m$。

\paragraph{组和数}
从 $n$ 个不同元素中取 $m$ 个不同元素组成的一组称作一个组合，则组合种数为
\[ C_n^m = \frac{n(n-1)\cdots(n-m+1)}{m!} = \frac{n!}{m!(n-m)!} \]
也记作 $\binom{n}{m}$。若元素可重复取出，则为 $\binom{n+m-1}{m}$。

\paragraph{圆排列}
将 $n$ 个元素不分首尾的排成一圈称作一个圆排列，则圆排列种数为 $(n-1)!$。

\paragraph{隔板法}
即 $n$ 个相同的球放进 $k$ 个盒子（要求盒子非空）里的种数为 $\binom{n-1}{m-1}$，即不定方程 $\sum x_m = n$ 的正整数解数。若允许盒子为空，则为 $\binom{n+k-1}{k-1}$。

\paragraph{错排公式}
每一个元素都不在自己的位置上的 $n$ 元排列称为一个错排，则错排种数为
\[ D_n = n! \left( 1 - \frac{1}{1!} + \frac{1}{2!} - \frac{1}{3!} + \cdots + \frac{(-1)^n}{n!} \right) = \left\lfloor \frac{n!}{\ee} + 0.5 \right\rfloor \]
其递推式为 $D_n = (n-1)(D_{n-1} + D_{n-2})$。

\subsection{常见公式}

\paragraph{组和数和式}
\[ \binom{n+1}{k} = \binom{n}{k} + \binom{n}{k-1}, \quad \binom{n}{k} = \frac{n}{k} \binom{n-1}{k-1} \]
\[ \sum\limits_{r=0}^k \binom{n+r-1}{r} = \binom{n+k}{k}, \quad \sum\limits_{r=0}^n \binom{n}{r}^2 = \binom{2n}{n} \]
\[ \binom{n}{i}\binom{i}{m} = \binom{n}{m}\binom{n-m}{i-m}, \quad \sum\limits_{i=m}^n \binom{i}{a} = \binom{n+1}{a+1} - \binom{m}{a+1} \]
\[ \sum\limits_{i=0}^k \binom{n}{i}\binom{m}{k-i} = \binom{n+m}{k}, \quad \sum\limits_{j=0}^k \binom{k}{j}^2 \binom{n+2k-j}{2k} = \binom{n+k}{k}^2 \]

\[ \sum\limits_{r=0}^n \binom{dn}{dr} = \frac{1}{d} \sum_{r=1}^d  \left( 1+\ee^{\tfrac{2\pi r i}{d}} \right)^{dn} \]

\paragraph{二项式反演}

注意到
\[ \sum_{k=0}^n (-1)^k \binom{n}{k} = [n=0] \]
于是有
\[ f(n) = \sum_{k=0}^n \binom{n}{k} g(k) \Rightarrow g(n) = \sum_{k=0}^n (-1)^{n-k}\binom{n}{k} f(k) \]






\chapter{图论}

\section{链式前项星}

\lstinputlisting[style=cpp,caption=/图论/链式前项星.cpp]{图论/链式前项星.cpp}

\section{最短路}

\subsection{Dijkstra}

权值必须是非负，复杂度 $O(E\log E)$。

\lstinputlisting[style=cpp,caption=/图论/最短路/Dijkstra.cpp]{图论/最短路/Dijkstra.cpp}

\subsection{Bellman-Ford}

复杂度 $O(VE)$。

\lstinputlisting[style=cpp,caption=/图论/最短路/Bellman-Ford.cpp]{图论/最短路/Bellman-Ford.cpp}

\subsection{Floyd}

起始条件 $f(i,j)={\rm edge}(i,j)$，$f(i,i)=0$。

\lstinputlisting[style=cpp,caption=/图论/最短路/Floyd.cpp]{图论/最短路/Floyd.cpp}

\section{最近公共祖先 LCA}

需要预处理 $\log_2$；如果数据小，直接莽 $20$。

\lstinputlisting[style=cpp,caption=图论/LCA.cpp]{图论/LCA.cpp}







\chapter{动态规划}

\section{背包}

\subsection{01 背包}

给定体积为 $v_i$，价值 $w_i$ 的 $N$ 个物品，背包容积为 $M$，每个物品只能取 $1$ 个，求最大价值。

\lstinputlisting[style=cpp,caption=/动态规划/01背包.cpp]{动态规划/01背包.cpp}

\subsection{完全背包}

给定体积为 $v_i$，价值 $w_i$ 的 $n$ 个物品，背包容积为 $v$，每个物品任意取，求最大价值。

\lstinputlisting[style=cpp,caption=/动态规划/完全背包.cpp]{动态规划/完全背包.cpp}

\subsection{多重背包}

给定体积为 $v_i$，价值 $w_i$ 的 $N$ 个物品，背包容积为 $M$，每个物品有 $c_i$ 个，求最大价值。

如各种背包组合（如洛谷 P1833 樱花），通常把完全背包转为 $99999$ 个（适当调节）多重背包，再按 01 背包来。

\lstinputlisting[style=cpp,caption=/动态规划/多重背包.cpp]{动态规划/多重背包.cpp}

\section{最长公共上升序列}

给出 $1,2,\ldots,n$ 的两个排列 $a$ 和 $b$ ，求它们的最长公共子序列。

\lstinputlisting[style=cpp,caption=/动态规划/最长公共上升序列.cpp]{动态规划/最长公共上升序列.cpp}

\section{数字计数}

试计算在区间 $1$ 到 $n$ 的所有整数中，数码 $x(0 \leqslant x \leqslant 9)$ 共出现了多少次？

\lstinputlisting[style=cpp,caption=/动态规划/数字计数/01.cpp]{动态规划/数字计数/01.cpp}

试计算在区间 $1$ 到 $n$ 的所有整数中，出现数码 $x(0 \leqslant x \leqslant 9)$ 的数字有多少？

\lstinputlisting[style=cpp,caption=/动态规划/数字计数/02.cpp]{动态规划/数字计数/02.cpp}







\chapter{数据结构}

\section{链表}

\lstinputlisting[style=cpp,caption=/数据结构/链表.cpp]{数据结构/链表.cpp}

链表的遍历。

\begin{lstlisting}[style=cpp]
for(Node *p=l->head->next; p!=l->tail; p=p->next)
    //正序遍历
for(Node *p=l->tail->prev; p!=l->head; p=p->prev)
    //逆序遍历
\end{lstlisting}

\section{滑动窗口}

\lstinputlisting[style=cpp,caption=/数据结构/滑动窗口.cpp]{数据结构/滑动窗口.cpp}

\section{树状数组}

树状数组可以维护数组 $a$ 实现 （1）将某个数加上 $x$。（2）求前缀和。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/01.cpp]{数据结构/树状数组/01.cpp}

\paragraph{区间加 \& 单点查询}

维护数组 $a$ 的额外差分数组 $b$，那么 $a$ 的区间加就被转化为 $b$ 的单点增加，且 $a$ 单点查询就被转化为 $b$ 的区间查询。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/02.cpp]{数据结构/树状数组/02.cpp}

\paragraph{区间加 \& 区间求和}

维护数组 $a$ 的额外差分数组 $b$，当我们对 $a$ 的前缀 $r$ 求和时有
$$\sum_{i=1}^r \sum_{j=1}^i b_j = \sum_{i=1}^rb_i(r-i+1) = (r+1)\sum_{i=1}^rb_i - \sum_{i=1}^rb_ii$$
因此还需要两个树状数组来维护 $\sum b_i$ 和 $\sum b_ii$。查询前缀和 \verb|cask|。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/03.cpp]{数据结构/树状数组/03.cpp}

\section{ST 表}

需要预处理 $\log_2$。令 $st(i,j)$ 表示区间 $[i,i+2^j-1]$ 的最大值，显然 $ST(i,0)=a_i$。状态转移方程
$$ST(i,j+1) = \max(f(i,j) , f(i+2^{j},j))$$

\lstinputlisting[style=cpp,caption=/数据结构/ST表/01.cpp]{数据结构/ST表/01.cpp}

对于 RMQ 问题，记 $s = \lfloor\log_2(r-l+1)\rfloor$，我们总是可以用两个区间 $[l,l+2^s-1]$ 和 $[r-2^s+1,r]$ 来覆盖所查询区间。

\lstinputlisting[style=cpp,caption=/数据结构/ST表/02.cpp]{数据结构/ST表/02.cpp}

\section{线段树}

单点修改，区间查询。

\lstinputlisting[style=cpp,caption=/数据结构/线段树/01.cpp]{数据结构/线段树/01.cpp}

区间修改，区间查询。

\lstinputlisting[style=cpp,caption=/数据结构/线段树/02.cpp]{数据结构/线段树/02.cpp}







\chapter{字符串}

\section{KMP}

\paragraph{前缀函数}

对于长为 $n$ 的字符串 $s$，定义每个位置的前缀函数 $\pi(i)$，值为 $s(0,i)$ 的真后缀与 $s$ 的真前缀中相等的最长的长度。

设最长的长度为 $j_1=\pi(i)$，如何找到其次长 $j_2$？

注意到后缀 $j_1$ 位与前缀 $j_1$ 位完全相同，故 $j_2$ 为前缀 $j_1$ 中相等真前缀与真后缀中最长的，即
\[j_{n+1} = \pi(j_n-1)\]

\lstinputlisting[style=cpp,caption=/字符串/KMP/01.cpp]{字符串/KMP/01.cpp}

\paragraph{Knuth - Morris - Pratt}

给定一个文本 $t$ 和一个字符串 $s$ （模式串），尝试找到 $s$ 在 $t$ 中所有出现。

构造字符串 $s+*+t$，其中 $*$ 为不出现在两个字符串中的特殊字符，此时字符串 $t$ 的前缀恰为 $s$，$\pi(i)$ 的意义为 $s$ 在此处的出现长度。

当 $\pi(i)=|s|$ 时，$s$ 在此处完全出现。

当字符串已经合并时，直接计算 $\pi(i)$ 函数即可，字符串出现位置是 $i-2|s|$。

\lstinputlisting[style=cpp,caption=/字符串/KMP/02.cpp]{字符串/KMP/02.cpp}

\paragraph{EXKMP}

对于长为 $n$ 的字符串 $s$，定义每个位置的后缀函数 $z(i)$，值为 $s(i,n-1)$ 的真前缀与 $s$ 真前缀中相等的最长的长度。

\lstinputlisting[style=cpp,caption=/字符串/KMP/03.cpp]{字符串/KMP/03.cpp}

\section{Manacher}

\lstinputlisting[style=cpp,caption=/字符串/Manacher/01.cpp]{字符串/Manacher/01.cpp}



\end{multicols}

\end{document}
