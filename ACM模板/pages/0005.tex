\chapter{数据结构}

\section{链表}

\lstinputlisting[style=cpp,caption=/数据结构/链表.cpp]{数据结构/链表.cpp}

链表的遍历。

\begin{lstlisting}[style=cpp]
for(Node *p=l->head->next; p!=l->tail; p=p->next)
    //正序遍历
for(Node *p=l->tail->prev; p!=l->head; p=p->prev)
    //逆序遍历
\end{lstlisting}

\section{树状数组}

树状数组可以维护数组 $a$ 实现 （1）将某个数加上 $x$。（2）求前缀和。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/01.cpp]{数据结构/树状数组/01.cpp}

\paragraph{区间加 \& 单点查询}

维护数组 $a$ 的额外差分数组 $b$，那么 $a$ 的区间加就被转化为 $b$ 的单点增加，且 $a$ 单点查询就被转化为 $b$ 的区间查询。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/02.cpp]{数据结构/树状数组/02.cpp}

\paragraph{区间加 \& 区间求和}

维护数组 $a$ 的额外差分数组 $b$，当我们对 $a$ 的前缀 $r$ 求和时有
$$\sum_{i=1}^r \sum_{j=1}^i b_j = \sum_{i=1}^rb_i(r-i+1) = (r+1)\sum_{i=1}^rb_i - \sum_{i=1}^rb_ii$$
因此还需要两个树状数组来维护 $\sum b_i$ 和 $\sum b_ii$。查询前缀和 \verb|cask|。

\lstinputlisting[style=cpp,caption=/数据结构/树状数组/03.cpp]{数据结构/树状数组/03.cpp}

\section{ST 表}

需要预处理 $\log_2$。令 $st(i,j)$ 表示区间 $[i,i+2^j-1]$ 的最大值，显然 $ST(i,0)=a_i$。状态转移方程
$$ST(i,j+1) = \max(f(i,j) , f(i+2^{j},j))$$

\lstinputlisting[style=cpp,caption=/数据结构/ST表/01.cpp]{数据结构/ST表/01.cpp}

对于 RMQ 问题，记 $s = \lfloor\log_2(r-l+1)\rfloor$，我们总是可以用两个区间 $[l,l+2^s-1]$ 和 $[r-2^s+1,r]$ 来覆盖所查询区间。

\lstinputlisting[style=cpp,caption=/数据结构/ST表/02.cpp]{数据结构/ST表/02.cpp}